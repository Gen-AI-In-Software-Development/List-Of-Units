#  Unit23-JavaScript-Examples
## Introduction
In this unit, we’ll explore various JavaScript examples generated by Microsoft Copilot. Our goal is to review the code produced and provide constructive feedback to ensure best practices and effective usage of JavaScript for creating dynamic and interactive web applications.
These examples use Microsoft copilot provided here: [Microsoft copilot](https://copilot.microsoft.com/).

## Use Case
JavaScript is a key programming language used to make web pages interactive and functional. It lets developers create content that can respond to user actions, control multimedia, and animate images. Along with HTML and CSS, JavaScript is a core part of web development.

JavaScript is not just for browsers; it can also be used on servers with Node.js, allowing developers to use the same language for both client-side and server-side coding. This makes development simpler and more efficient.

JavaScript is essential for modern web frameworks like React, Angular, and Vue.js, which help build complex web applications. It’s also used in mobile app development (React Native), desktop app development (Electron), and game development.

In this unit, we will create various JavaScript examples and use Copilot to demonstrate different concepts, techniques, and best practices.

## Prompts and Code Critique
We will show each prompt and the resulting code generated by Copilot. We will follow each example with a short critique and rating. The ratings will be Poor, Fair, or Good.

### Prompt 23.1 : Write a Node.js program that uses console.log to print all the numbers from 1 to 100, with two exceptions. For numbers divisible by 3, print "Fizz" instead of the number, and for numbers divisible by 5 (and not 3), print "Buzz" instead.When you have that working, modify your program to print "FizzBuzz" for numbers that are divisible by both 3 and 5 (and still print "Fizz" or "Buzz" for numbers divisible by only one of those).
### Generated Code
```
for (let i = 1; i <= 100; i++) {
    let output = '';
    if (i % 3 === 0) output += 'Fizz';
    if (i % 5 === 0) output += 'Buzz';
    console.log(output || i);
}

```

### Critique 

### Prompt 23.2 :Write a Node.js program that creates a string that represents an 8×8 grid, using newline characters to separate lines. At each position of the grid there is either a space or a "#" character. The characters should form a chessboard.
Passing this string to console.log should show something like this:
# # # #
 # # # #
# # # #
 # # # #
# # # # 
 # # # #
# # # # 
 # # # #

### Generated Code
```
let size = 8;
let board = "";

for (let y = 0; y < size; y++) {
  for (let x = 0; x < size; x++) {
    if ((x + y) % 2 == 0) {
      board += " ";
    } else {
      board += "#";
    }
  }
  board += "\n";
}

console.log(board);

```
### Critique 

### Prompt 23.3 :Bean counting
You can get the Nth character, or letter, from a string by writing "string"[N]. The returned value will be a string containing only one character (for example, "b"). The first character has position 0, which causes the last one to be found at position string.length - 1. In other words, a two-character string has length 2, and its characters have positions 0 and 1.
Write a function countBs that takes a string as its only argument and returns a number that indicates how many uppercase “B” characters there are in the string.
Next, write a function called countChar that behaves like countBs, except it takes a second argument that indicates the character that is to be counted (rather than counting only uppercase “B” characters). Rewrite countBs to make use of this new function. 

### Generated Code
```
const readline = require('readline').createInterface({
  input: process.stdin,
  output: process.stdout
});

// Define a function countChar that counts the number of occurrences of a specific character in a string
function countChar(str, char) {
  let count = 0;
  for (let i = 0; i < str.length; i++) {
    if (str[i] === char) {
      count++;
    }
  }
  return count;
}

// Define a function countBs that counts the number of uppercase "B" characters in a string
function countBs(str) {
  return countChar(str, 'B');
}

// Function to get user input and call countBs and countChar
function getUserInput() {
  readline.question('Enter a string: ', (userString) => {
    readline.question('Enter a character to count: ', (userChar) => {
      console.log(`The character "${userChar}" appears ${countChar(userString, userChar)} times in the string.`);
      console.log(`The letter "B" appears ${countBs(userString)} times in the string.`);
      readline.close();
    });
  });
}

// Call the function to start the program
getUserInput();

```
### Critique 

### Prompt 23.4 : Dominant writing direction
					
Write a function that computes the dominant writing direction in a string of text. Remember that each script object has a direction property that can be "ltr" (left to right), "rtl" (right to left), or "ttb" (top to bottom).
					
The dominant direction is the direction of a majority of the characters that have a script associated with them. The characterScript and countBy func- tions defined earlier in the chapter are probably useful here. 

### Generated Code
```
```
### Critique 

### Prompt 23.5 :Quoting style
					
Imagine you have written a story and used single quotation marks throughout to mark pieces of dialogue. Now you want to replace all the dialogue quotes with double quotes, while keeping the single quotes used in contractions like aren’t.
					
Think of a pattern that distinguishes these two kinds of quote usage and craft a call to the replace method that does the proper replacement. 

### Generated Code
```
function replaceQuotes(text) {
  var replacedText = text.replace(/(^|\W)'|'(\W|$)/g, '$1"$2');
  return replacedText;
}

// Example usage:
var story = "She said, 'Hello, aren't you coming?' and then left.";
var updatedStory = replaceQuotes(story);
console.log(updatedStory);

```
### Critique 

### Prompt 23.6 : Conway’s Game of Life is a simple simulation that creates artificial “life” on a grid, each cell of which is either alive or not. Each generation (turn), the following rules are applied:					
• Any live cell with fewer than two or more than three live neighbors dies.	
• Any live cell with two or three live neighbors lives on to the next gener- ation.
• Any dead cell with exactly three live neighbors becomes a live cell.
A neighbor is defined as any adjacent cell, including diagonally adjacent ones.
Note that these rules are applied to the whole grid at once, not one square at a time. That means the counting of neighbors is based on the situation at the start of the generation, and changes happening to neighbor cells during this generation should not influence the new state of a given cell.
Implement this game using whichever data structure you find appropriate. Use Math.random to populate the grid with a random pattern initially. Display it as a grid of checkbox fields, with a button next to it to advance to the next generation. When the user checks or unchecks the checkboxes, their changes should be included when computing the next generation. 

### Generated Code
```
```
### Critique 
## Exercises
1. For Prompt 23.2 ask Copilot to define a binding size = 8 and change the program so that it works for any size, outputting a grid
of the given width and height.


## References
