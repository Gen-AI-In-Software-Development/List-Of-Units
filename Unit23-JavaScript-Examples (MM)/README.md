#  Unit23-JavaScript-Examples
## Introduction
In this unit, we’ll explore various JavaScript examples generated by Microsoft Copilot. Our goal is to review the code produced and provide constructive feedback to ensure best practices and effective usage of JavaScript for creating dynamic and interactive web applications.
These examples use Microsoft copilot provided here: [Microsoft copilot](https://copilot.microsoft.com/).

## Use Case
JavaScript is a key programming language used to make web pages interactive and functional. It lets developers create content that can respond to user actions, control multimedia, and animate images. Along with HTML and CSS, JavaScript is a core part of web development.

JavaScript is not just for browsers; it can also be used on servers with Node.js, allowing developers to use the same language for both client-side and server-side coding. This makes development simpler and more efficient.

JavaScript is essential for modern web frameworks like React, Angular, and Vue.js, which help build complex web applications. It’s also used in mobile app development (React Native), desktop app development (Electron), and game development.

In this unit, we will create various JavaScript examples and use Copilot to demonstrate different concepts, techniques, and best practices.

## Prompts and Code Critique
We will show each prompt and the resulting code generated by Copilot. We will follow each example with a short critique and rating. The ratings will be Poor, Fair, or Good.

### Prompt 23.1 : Write a Node.js program that uses console.log to print all the numbers from 1 to 100, with two exceptions. For numbers divisible by 3, print "Fizz" instead of the number, and for numbers divisible by 5 (and not 3), print "Buzz" instead.When you have that working, modify your program to print "FizzBuzz" for numbers that are divisible by both 3 and 5 (and still print "Fizz" or "Buzz" for numbers divisible by only one of those) [1].
### Generated Code
```
for (let i = 1; i <= 100; i++) {
    let output = '';
    if (i % 3 === 0) output += 'Fizz';
    if (i % 5 === 0) output += 'Buzz';
    console.log(output || i);
}

```

### Critique 
The Node.js program effectively prints numbers from 1 to 100, replacing numbers divisible by 3 with “Fizz”, numbers divisible by 5 with “Buzz”, and numbers divisible by both with “FizzBuzz”. The use of conditional statements and string concatenation is efficient and concise. Rating: Good


### Prompt 23.2 :Write a Node.js program that creates a string that represents an 8×8 grid, using newline characters to separate lines. At each position of the grid there is either a space or a "#" character. The characters should form a chessboard [2].

### Generated Code
```
let size = 8;
let board = "";

for (let y = 0; y < size; y++) {
  for (let x = 0; x < size; x++) {
    if ((x + y) % 2 == 0) {
      board += " ";
    } else {
      board += "#";
    }
  }
  board += "\n";
}

console.log(board);

```
### Critique 
The Node.js program effectively generates an 8x8 chessboard pattern using nested loops and conditional logic to alternate spaces and “#” characters. The use of newline characters to separate lines is correctly implemented. Rating: Good.

### Prompt 23.3 :Bean counting You can get the Nth character, or letter, from a string by writing "string"[N]. The returned value will be a string containing only one character (for example, "b"). The first character has position 0, which causes the last one to be found at position string.length - 1. In other words, a two-character string has length 2, and its characters have positions 0 and 1. Write a function countBs that takes a string as its only argument and returns a number that indicates how many uppercase “B” characters there are in the string. Next, write a function called countChar that behaves like countBs, except it takes a second argument that indicates the character that is to be counted (rather than counting only uppercase “B” characters). Rewrite countBs to make use of this new function [3]. 

### Generated Code
```
const readline = require('readline').createInterface({
  input: process.stdin,
  output: process.stdout
});

// Define a function countChar that counts the number of occurrences of a specific character in a string
function countChar(str, char) {
  let count = 0;
  for (let i = 0; i < str.length; i++) {
    if (str[i] === char) {
      count++;
    }
  }
  return count;
}

// Define a function countBs that counts the number of uppercase "B" characters in a string
function countBs(str) {
  return countChar(str, 'B');
}

// Function to get user input and call countBs and countChar
function getUserInput() {
  readline.question('Enter a string: ', (userString) => {
    readline.question('Enter a character to count: ', (userChar) => {
      console.log(`The character "${userChar}" appears ${countChar(userString, userChar)} times in the string.`);
      console.log(`The letter "B" appears ${countBs(userString)} times in the string.`);
      readline.close();
    });
  });
}

// Call the function to start the program
getUserInput();

```
### Critique 
The Node.js program correctly implements the countBs and countChar functions to count occurrences of characters in a string, with a user-friendly interface for input. The code effectively reuses the countChar function in countBs and employs readline for input, enhancing interactivity. Overall, the program demonstrates clear logic and good use of modular functions.
Rating: Good

### Prompt 23.4 : On Unix systems, there is a command line tool called grep that can be used to quickly search files for a regular expression. Write a Node script that can be run from the command line and acts some- what like grep. It treats its first command line argument as a regular expression and treats any further arguments as files to search. It should output the names of any file whose content matches the regular expression. When that works, extend it so that when one of the arguments is a directory, it searches through all files in that directory and its subdirectories. Use asynchronous or synchronous file system functions as you see fit. Setting things up so that multiple asynchronous actions are requested at the same time might speed things up a little, but not a huge amount, since most file systems can read only one thing at a time [4].

### Generated Code
```
const fs = require('fs');
const path = require('path');

// Function to recursively read directories and search files
function searchFiles(directory, regex) {
  fs.readdir(directory, { withFileTypes: true }, (err, entries) => {
    if (err) {
      console.error(`Error reading directory ${directory}: ${err}`);
      return;
    }

    entries.forEach(entry => {
      const fullPath = path.join(directory, entry.name);
      if (entry.isDirectory()) {
        searchFiles(fullPath, regex); // Recurse into subdirectories
      } else {
        fs.readFile(fullPath, 'utf8', (err, content) => {
          if (err) {
            console.error(`Error reading file ${fullPath}: ${err}`);
            return;
          }
          if (regex.test(content)) {
            console.log(fullPath); // Output the file name if content matches
          }
        });
      }
    });
  });
}

// Main script
const regexPattern = process.argv[2];
const searchPath = process.argv[3];

if (!regexPattern || !searchPath) {
  console.error('Usage: node grep.js <regex-pattern> <path>');
  process.exit(1);
}

const regex = new RegExp(regexPattern);

fs.stat(searchPath, (err, stats) => {
  if (err) {
    console.error(`Error accessing path ${searchPath}: ${err}`);
    process.exit(1);
  }

  if (stats.isDirectory()) {
    searchFiles(searchPath, regex);
  } else {
    fs.readFile(searchPath, 'utf8', (err, content) => {
      if (err) {
        console.error(`Error reading file ${searchPath}: ${err}`);
        process.exit(1);
      }
      if (regex.test(content)) {
        console.log(searchPath); // Output the file name if content matches
      }
    });
  }
});

```
### Critique 
The Node.js script effectively mimics the Unix grep command, handling both files and directories recursively, and uses asynchronous file system functions for efficient I/O operations. It demonstrates good structure and clear logic for searching file contents with regular expressions. Rating: Good

### Prompt 23.5 :Quoting style, Imagine you have written a story and used single quotation marks throughout to mark pieces of dialogue. Now you want to replace all the dialogue quotes with double quotes, while keeping the single quotes used in contractions like aren’t. Think of a pattern that distinguishes these two kinds of quote usage and craft a call to the replace method that does the proper replacement [5]. 

### Generated Code
```
function replaceQuotes(text) {
  var replacedText = text.replace(/(^|\W)'|'(\W|$)/g, '$1"$2');
  return replacedText;
}

// Example usage:
var story = "She said, 'Hello, aren't you coming?' and then left.";
var updatedStory = replaceQuotes(story);
console.log(updatedStory);

```
### Critique 
The Node.js function effectively replaces single quotation marks used for dialogue with double quotation marks, while preserving single quotes used in contractions. The use of a regular expression with capturing groups ensures accurate replacements. Rating: Good

### Prompt 23.6 : Write a page that displays a balloon (using the balloon emoji, 🎈). When you press the up arrow, it should inflate (grow) 10 percent, and when you press the down arrow, it should deflate (shrink) 10 percent.You can control the size of text (emoji are text) by setting the font-size CSS property (style.fontSize) on its parent element. Remember to include a unit in the value—for example, pixels (10px). The key names of the arrow keys are "ArrowUp" and "ArrowDown". Make sure the keys change only the balloon, without scrolling the page. When that works, add a feature where, if you blow up the balloon past a certain size, it explodes. In this case, exploding means that it is replaced with an 💥 emoji, and the event handler is removed (so that you can’t inflate or deflate the explosion). Write a Javascript program [6].
### Generated Code
```
// Get the balloon element
const balloon = document.getElementById("balloon");

// Initial font size (10px)
let fontSize = 10;

// Event listener for arrow keys
document.addEventListener("keydown", (event) => {
    if (event.key === "ArrowUp") {
        // Inflate the balloon (increase font size by 10%)
        fontSize *= 1.1;
        // Prevent default to stop the page from scrolling
        event.preventDefault();
        balloon.style.fontSize = fontSize + "px";
    } else if (event.key === "ArrowDown") {
        // Deflate the balloon (decrease font size by 10%)
        fontSize *= 0.9;
        // Prevent default to stop the page from scrolling
        event.preventDefault();
        balloon.style.fontSize = fontSize + "px";
    }

    // Check if balloon has exploded
    if (fontSize > 50) { // Set the explosion size limit
        // Replace balloon with explosion emoji
        balloon.textContent = "💥";
        // Remove event listener to prevent further inflation/deflation
        document.removeEventListener("keydown", event);
    }
});


```

```
<!DOCTYPE html>
<html>
<head>
<title>Balloon Fun</title>
</head>
<body>
<span id="balloon" style="font-size: 10px;">🎈</span>
<script src="path_to_your_javascript_file.js"></script>
</body>
</html>
```

### Critique 
The JavaScript code effectively handles the inflation and deflation of a balloon emoji based on arrow key presses and implements an explosion feature when the balloon grows too large. It correctly uses event listeners and CSS manipulation for the desired behavior. Rating: Good

## Exercises
1. For Prompt 23.1 ask Copilot to modify the FizzBuzz program to add a condition to print “BuzzFizz” for numbers divisible by 7. And allow the range of numbers (e.g., 1 to 100) to be 
  specified via command line arguments.
2. For Prompt 23.2 ask Copilot to define a binding size = 8 and change the program so that it works for any size, outputting a grid of the given width and height.
3. For Prompt 23.3 ask Copilot to modify the countChar and countBs functions to perform case-insensitive counting of characters (e.g., count both ‘B’ and ‘b’).
4. For Prompt 23.4 ask Copilot to extend the grep-like script to accept multiple regular expressions and search for files that match any of the expressions.
5. For Prompt 23.4 ask Copilot to enhance the balloon game to include a feature where the balloon starts to deflate if it shrinks below a certain size, turning it back into a balloon emoji.



## References
[1] Haverbeke, Marijn, *Eloquent JavaScript*, 3rd edn (San Francisco: No Starch Press, 2018), pp. 38, ISBN 978-1-59327-950-9.

[2] Haverbeke, Marijn, *Eloquent JavaScript*, 3rd edn (San Francisco: No Starch Press, 2018), pp. 38, ISBN 978-1-59327-950-9.

[3] Haverbeke, Marijn, *Eloquent JavaScript*, 3rd edn (San Francisco: No Starch Press, 2018), pp. 56, ISBN 978-1-59327-950-9.

[4] Haverbeke, Marijn, *Eloquent JavaScript*, 3rd edn (San Francisco: No Starch Press, 2018), pp. 367, ISBN 978-1-59327-950-9.

[5] Haverbeke, Marijn, *Eloquent JavaScript*, 3rd edn (San Francisco: No Starch Press, 2018), pp. 165-166, ISBN 978-1-59327-950-9.

[6] Haverbeke, Marijn, *Eloquent JavaScript*, 3rd edn (San Francisco: No Starch Press, 2018), pp. 259, ISBN 978-1-59327-950-9.

