#  Unit04-Python-Examples
## Introduction
In this unit, we’ll explore various Python programming examples generated by Microsoft Copilot. Our goal is to review the code produced and provide constructive feedback.

These examples use Microsoft copilot provided here: [Microsoft copilot](https://copilot.microsoft.com/).
## Use Case
The prompts and code snippets presented here align with the level typically encountered in an introductory Python course or an introductory computer science course that utilizes Python.

## Prompts and Code Critique
We will show each prompt and the resulting code generated by Copilot. We will follow each example
with a short critique and rating. The ratings will be Poor, Fair, or Good.

### Example 3.1 prompt:  Write a Python program that displays the text

### hello, world!

### on the user's screen.

### Generated Code
```
# Print the desired text to the screen
print("hello, world!")
```
### Critique
A brief and correct Python program that does as requested, including an appropriate comment.  The prompt was intentionally unsophisticated.  Rating: Good
### Example 3.2 prompt:  Write a Python function that converts from Fahrenheit to Celsius.  Create five test cases that show the results of this conversion to the user, using reasonable example Fahrenheit temperatures.

### Generated Code
```
def fahrenheit_to_celsius(fahrenheit):
    """
    Converts a temperature from Fahrenheit to Celsius.

    Args:
        fahrenheit (float): Temperature in Fahrenheit.

    Returns:
        float: Temperature in Celsius.
    """
    celsius = (fahrenheit - 32) * 5 / 9
    return celsius

# Test cases
test_temperatures = [32, 68, 100, 212, 50]

for temp_f in test_temperatures:
    temp_c = fahrenheit_to_celsius(temp_f)
    print(f"{temp_f}°F is approximately {temp_c:.2f}°C")
```
### Critique
This time, we ask for a function that performs a calculation, and for five "random" but reasonable tests to be performed.  Notice that we did not specify the conversion formula: we relied on Copilot to figure out what Fahrenheit and Celsius mean and how to do the conversion.  Copilot produces a cleanly defined function with an appropriate name, a clear docstring that tells how to use the function, and a correct conversion formula.  The "random" but reasonable test cases include 32 (freezing), 212 (boiling), and three intermediate temperatures: 50 (cool), 68 (pleasant), and 100 (hot).  The resulting output is nicely formatted with two digits of precision after the decimal point for the Celsius conversion.  Overall: This code is quite remarkable, given the complete but sparse nature of the prompt.  Rating: Good.
### Example 3.3 prompt:  In the Fahrenheit to Celsius conversion code, instead of displaying five conversions on the screen, write a table of conversions to an output file named F_to_C.csv.  The name of the first output column should be Fahr, and the second output column should be Cels.  Perform conversions for temperatures ranging from 0 to 200, in steps of 5.

### Generated Code
```
import csv

def fahrenheit_to_celsius(fahrenheit):
    """
    Converts a temperature from Fahrenheit to Celsius.

    Args:
        fahrenheit (float): Temperature in Fahrenheit.

    Returns:
        float: Temperature in Celsius.
    """
    celsius = (fahrenheit - 32) * 5 / 9
    return celsius

# Create a list of Fahrenheit temperatures from 0 to 200 (in steps of 5)
fahrenheit_values = list(range(0, 201, 5))

# Calculate Celsius values for each Fahrenheit temperature
celsius_values = [fahrenheit_to_celsius(temp_f) for temp_f in fahrenheit_values]

# Write the data to a CSV file
with open("F_to_C.csv", mode="w", newline="") as csvfile:
    writer = csv.writer(csvfile)
    writer.writerow(["Fahr", "Cels"])  # Write header row
    for f, c in zip(fahrenheit_values, celsius_values):
        writer.writerow([f, c])
```
### Critique
With this prompt, we require Copilot to remember what it did for us previously, and to make changes.  The output is to be written to a comma-separated value file, but we don't say that explicitly: we imply it via the requested output file name, F_to_C.csv.  Copilot knows how to import the csv module and use the csv.writer() to get this to work.  For the celsius_values list, Copilot makes nice use of a list comprehension.  Overall: a clean, well written, well commented program, that does exactly as desired.  Rating: Good.
### Example 3.4 prompt:  The patients.csv file contains patient information for a doctor's office.  Write Python code that reads the contents of the patients.csv file, and that then displays the following:  
### a.  The entire patient list, ordered by age.  
### b.  The list of women, ordered by height.  
### c.  The average age of the men.  
### d.  The median weight of the women.  
### Generated Results
```
Certainly! Let’s break down the tasks and write Python code to accomplish each one:

1. Reading the CSV File: We’ll start by reading the contents of the patients.csv file. We can use either the built-in csv module or the pandas library. I’ll demonstrate both approaches:

a. Using the csv Module:
# Python

import csv

# Read the CSV file
with open('patients.csv', 'r') as file:
    reader = csv.reader(file)
    patient_list = list(reader)  # Convert to a list of lists

# Display the entire patient list (ordered by age)
sorted_patient_list = sorted(patient_list[1:], key=lambda x: int(x[2]))  # Assuming age is in column 2
for patient in sorted_patient_list:
    print(f"Name: {patient[0]}, Age: {patient[2]}, Gender: {patient[1]}, Height: {patient[3]}, Weight: {patient[4]}")

b. Using pandas:
# Python

import pandas as pd

# Read the CSV file into a DataFrame
df = pd.read_csv('patients.csv')

# Display the entire patient list (ordered by age)
sorted_df = df.sort_values(by='Age')  # Assuming 'Age' is the column name
print(sorted_df)

# Extract women and men separately
women_df = df[df['Gender'] == 'Female']
men_df = df[df['Gender'] == 'Male']

# Display the list of women (ordered by height)
sorted_women_df = women_df.sort_values(by='Height')
print(sorted_women_df)

# Calculate the average age of men
average_age_men = men_df['Age'].mean()
print(f"Average age of men: {average_age_men:.2f}")

# Calculate the median weight of women
median_weight_women = women_df['Weight'].median()
print(f"Median weight of women: {median_weight_women:.2f}")
```
### Critique
With this prompt, we ask Copilot to analyze a comma separated data file that it does not know anything about, except that it is "patient data" for a doctor's office.  Copilot analyzes the patients.csv file itself, and draws conclusions about the content.  Here is what the file contains:

Name,Age,Gender,Height,Weight  
Alan,30,M,67,125  
Betty,29,F,64,115  
Carl,25,M,69,165  
Donna,42,F,60,105  
Eric,27,M,71,180  
Fred,29,M,69,168  
Gina,33,F,65,133  
Harry,40,M,68,203  
Ida,54,F,62,144  
John,67,M,70,222  
Karla,48,F,69,142  
Lars,37,M,73,191  

Copilot's attempt (a) using the csv module is close, but not correct: for some reason, Copilot thinks the Age is column sub-2 rather than sub-1 (columns in Python are indexed 0, 1, 2, ...).  Hence, the code as written fails, producing this error:  
  
Traceback (most recent call last):  
  File "C:/Users/jostlund/Downloads/disp_patients.py", line 9, in <module>  
    sorted_patient_list = sorted(patient_list[1:], key=lambda x: int(x[2]))  # Assuming age is in column 2  
  File "C:/Users/jostlund/Downloads/disp_patients.py", line 9, in <lambda>  
    sorted_patient_list = sorted(patient_list[1:], key=lambda x: int(x[2]))  # Assuming age is in column 2  
ValueError: invalid literal for int() with base 10: 'M'  
  
A skilled Python programmer will catch that Age is column sub-1, and Gender is column sub-2, and can correct the program by making changes in two lines of code.  This code using the csv module also only tries to display the entire patient list, not the other three statistics.
  
Copilot's attempt (b) using the pandas module is better, with one flaw: even after examining the input file, Copilot assumes the possible genders are 'Male' and 'Female' rather than the actual 'M' and 'F'.  If corrected by a skilled programmer, the version (b) code runs correctly.
  
Overall:  Very useful, but not perfect.  In both cases (a) and (b) the code can be corrected easily by a skilled Python programmer.  Rating: Fair.
### Example 3.5 prompt:  Repeat the code for patients.csv, but notice that 'Age' is in column 1 (counting from 0) and 'Gender' is in column 2.  Also, notice that the two 'Gender' values are 'M' and 'F' rather than 'Male' and 'Female'.
### Generated Results
```
import pandas as pd

# Read the CSV file into a DataFrame
df = pd.read_csv('patients.csv')

# Display the entire patient list (ordered by age)
sorted_df = df.sort_values(by='Age')  # Assuming 'Age' is in column 1
print(sorted_df)

# Extract women and men separately
women_df = df[df['Gender'] == 'F']  # Assuming 'Gender' values are 'M' and 'F'
men_df = df[df['Gender'] == 'M']

# Display the list of women (ordered by height)
sorted_women_df = women_df.sort_values(by='Height')
print(sorted_women_df)

# Calculate the average age of men
average_age_men = men_df['Age'].mean()
print(f"Average age of men: {average_age_men:.2f}")

# Calculate the median weight of women
median_weight_women = women_df['Weight'].median()
print(f"Median weight of women: {median_weight_women:.2f}")
```
### Critique
With this prompt, we ask Copilot to try again, correcting the two incorrect assumptions it made with the first versions of the code.  Copilot abandons producing a csv module solution, and produces a pandas module solution that is correct.  Notice that Copilot was able to distinguish men and women from the Gender values 'M' and 'F'.  Overall:  With minor tuning of the prompt, we got a correct program from Copilot.  Nicely done!  Rating: Good.
### Example 3.6 prompt:  Create a Python class named BST that implements a Binary Search Tree of numeric values.
### Generated Results
```
Certainly! Here’s a Python class named BST that implements a Binary Search Tree (BST) for numeric values:

Python

class TreeNode:
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None

class BST:
    def __init__(self):
        self.root = None

    def insert(self, value):
        """
        Inserts a value into the BST.
        """
        if not self.root:
            self.root = TreeNode(value)
        else:
            self._insert_recursive(self.root, value)

    def _insert_recursive(self, node, value):
        """
        Helper function for recursive insertion.
        """
        if value < node.value:
            if node.left:
                self._insert_recursive(node.left, value)
                
            else:
                node.left = TreeNode(value)
        else:
            if node.right:
                self._insert_recursive(node.right, value)
            else:
                node.right = TreeNode(value)

    def search(self, value):
        """
        Searches for a value in the BST.
        Returns True if found, False otherwise.
        """
        return self._search_recursive(self.root, value)

    def _search_recursive(self, node, value):
        """
        Helper function for recursive search.
        """
        if not node:
            return False
        if node.value == value:
            return True
        elif value < node.value:
            return self._search_recursive(node.left, value)
        else:
            return self._search_recursive(node.right, value)

    def inorder_traversal(self):
        """
        Performs an inorder traversal of the BST.
        Returns a list of values in sorted order.
        """
        result = []
        self._inorder_recursive(self.root, result)
        return result

    def _inorder_recursive(self, node, result):
        """
        Helper function for recursive inorder traversal.
        """
        if node:
            self._inorder_recursive(node.left, result)
            result.append(node.value)
            self._inorder_recursive(node.right, result)

# Example usage
bst = BST()
bst.insert(5)
bst.insert(3)
bst.insert(8)
bst.insert(1)
bst.insert(4)
bst.insert(7)

print("Inorder traversal:", bst.inorder_traversal())
print("Search for 4:", bst.search(4))
print("Search for 6:", bst.search(6))
```
### Critique
Copilot provides a working implementation of a Binary Search Tree of numbers, in which at each node lesser values are stored in the left subtree and greater values in the right.  The BST uses a hierarchy of TreeNode objects, where the TreeNode class is defined outside of the BST class.  This is okay but not ideal: we would prefer that TreeNode be internal to BST.  As example methods, Copilot provides working implementations of \_\_init\_\_() (constructor), insert(), inorder_traversal() returning a list, and search() returning True or False.  These are the minimum necessary methods for a useful Binary Search Tree.  Copilot also creates test code to create an empty BST, insert six unique integer values into it, display the inorder_traversal() list, and search() for one value that exists and one value that does not exist in the BST.  This is a reasonable minimum sequence of tests.  We would prefer that this test code be incorporated in such a way that it is not executed if another program imports this BST code as a module.  The code is neatly written, well commented, and uses good variable and method names.  Overall:  Remarkably good code from such a terse prompt.  Of course, the Binary Search Tree is a very well known data structure.  Rating: Good.
### Example 3.7 prompt:  Revise the Python BST class so that TreeNode is internal to BST, and so that the test code followig the BST class is only executed if this BST class code is the main module.  Add another dozen test values, including some duplicate values, to demonstrate that duplicate values are not stored in the BST.
### Generated Results
```
I’ve revised the BST class according to your instructions. Now, the TreeNode class is nested within the BST class, making it an internal class. Additionally, the test code is wrapped in an if __name__ == "__main__": block to ensure it only executes when the module is run as the main program.

Here’s the updated class with the changes:

Python

class BST:
    class TreeNode:
        def __init__(self, value):
            self.value = value
            self.left = None
            self.right = None

    def __init__(self):
        self.root = None

    def insert(self, value):
        if not self.root:
            self.root = self.TreeNode(value)
        else:
            self._insert_recursive(self.root, value)

    def _insert_recursive(self, node, value):
        if value == node.value:
            return  # Duplicate value, do not insert into the BST
        if value < node.value:
            if node.left:
                self._insert_recursive(node.left, value)
            else:
                node.left = self.TreeNode(value)
        else:
            if node.right:
                self._insert_recursive(node.right, value)
            else:
                node.right = self.TreeNode(value)

    def search(self, value):
        return self._search_recursive(self.root, value)

    def _search_recursive(self, node, value):
        if not node:
            return False
        if node.value == value:
            return True
        elif value < node.value:
            return self._search_recursive(node.left, value)
        else:
            return self._search_recursive(node.right, value)

    def inorder_traversal(self):
        result = []
        self._inorder_recursive(self.root, result)
        return result

    def _inorder_recursive(self, node, result):
        if node:
            self._inorder_recursive(node.left, result)
            result.append(node.value)
            self._inorder_recursive(node.right, result)

if __name__ == "__main__":
    bst = BST()
    test_values = [5, 3, 8, 1, 4, 7, 2, 6, 9, 5, 8, 10, 5, 7, 11, 3, 4, 1, 0, 12, 13, 14]
    for val in test_values:
        bst.insert(val)

    print("Inorder traversal:", bst.inorder_traversal())
    print("Search for 4:", bst.search(4))
    print("Search for 6:", bst.search(6))

AI-generated code. Review and use carefully. More info on FAQ.
I’ve also added a check in the _insert_recursive method to prevent the insertion of duplicate values into the BST. The test values include some duplicates to demonstrate that they are not stored in the BST.

When I ran this code, the output was:

Inorder traversal: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]
Search for 4: True
Search for 6: True

As you can see, the inorder traversal does not include any duplicate values, indicating that the BST is functioning as expected. If you need further assistance or modifications, feel free to ask!
```
### Critique
Copilot created revised code as requested, and modified the insert() method to disallow insertion of duplicate values.  The original insert() code did allow duplicates, which your humble reviewer failed to notice!  The revised test code has been placed below an "if ... '__main__':" check so that this code can be imported as a module by another program without its test code being executed.  The revised test code does demonstrate that duplicate insertions are ignored.  Overall:  Well and cleanly revised code.  Rating: Good.
# Several Solved Examples Using Copilot
## Critical Evaluations of the Examples
## Exercises
## References
