#  Unit15-Designing-REST-APIs

## Introduction
In this unit, we will explore a simple client and server application that uses the REST architectural style.
We will ask copilot to help us generate the server side code using IntelliJ Ultimate's implementation of JAX-RS.
Then, we will ask copilot to generate the client side code using Java and ask it to encapsulate the communication code in methods separate from the main class.

These examples use Microsoft copilot provided here: [Microsoft copilot](https://copilot.microsoft.com/).

## Use Case

The World Wide Web has been hugely successful. A browser is used to interact with a server via HTTP, URLs, and a standard data representation such as HTML.

RESTful APIs are based on the same principles that were used in the construction of the web. For the origination and detailed explanation of these principles, see Roy Fieldingâ€™s PhD thesis[1]. This approach to API design has become widely popular. For two examples, see OData[2] and Amazon S3[3], which both utilize RESTful principles in their APIs.

## Prompts and Code Critique

We will show each prompt and the resulting code or response generated by Copilot. We will follow each example
with a short critique and rating. The ratings will be Poor, Fair, or Good.

### Example 15.1 prompt: Please explain any architectural advantages of developing a REST API.

### Notes on Copilot response
```
Copilot cited each comment with web URLs. It mentioned the following advantages:
Interoperability because REST is based on standard protocols
Flexibility of integrating with different types of systems (web and mobile)
Language independence from any particular programming language
Easy maintenance allowing easy updates due to modular nature of REST API's
REST APIs are stateless and client side state need not be maintained on the server which simplifies requests and responses
REST APIs are popular

```
### Critique
While essentially correct, the answer did not mention that REST APIs are textual, providing human readability. And if by "request" and "response" it means the request and response messages, there is an error. The request and response messages may be more complicated in a REST API than in an API where the server tracks application state.  Also, copilot did
not make clear what the distinction is between "interoperability" and "flexibility". Rating: Poor

### Example 15.2 prompt: I would like to use IntelliJ Ultimate and the built in Jakarta EE implementation of the Java API for RESTful web services (JAX-RS). Please provide a simple example of a Java program that makes available a REST API. In particular, I would like to make available a single resource (a BigInteger) that can be read or written by a web service  client.

### Code generated by copilot
```
import javax.ws.rs.*;
import javax.ws.rs.core.MediaType;
import java.math.BigInteger;

@Path("/biginteger")
public class BigIntegerResource {

    private BigInteger value = BigInteger.ZERO;

    @GET
    @Produces(MediaType.TEXT_PLAIN)
    public String getBigInteger() {
        return value.toString();
    }

    @PUT
    @Consumes(MediaType.TEXT_PLAIN)
    public void setBigInteger(String newValue) {
        value = new BigInteger(newValue);
    }
}

With a browser, navigate to http://localhost:8080/YourProjectName/api/biginteger for a GET request.
Using curl, do the following for a PUT request:
curl -X PUT -d "123456789" http://localhost:8080/YourProjectName/api/biginteger


```
### Critique
This is a very nice example of a REST service encapsulating a Java BigInteger. A GET request will allow a client to view the BigInteger as a String. A PUT request will allow a client to pass a String and set the BigInteger to some value.
As noted below the code, copilot also provided a URL for a browser to use for a GET request and the curl command
that can be used for a PUT request. Rating: Good


### Example 15.3 prompt: Continuing with our discussion, what I need now is an example Java client that shows how the client can read and write the BigInteger.  

### Code generated by copilot
```

import org.apache.http.HttpResponse;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.client.methods.HttpPut;
import org.apache.http.entity.StringEntity;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClients;
import org.apache.http.util.EntityUtils;

import java.math.BigInteger;

public class BigIntegerClient {

    public static void main(String[] args) {
        try (CloseableHttpClient httpClient = HttpClients.createDefault()) {
            // Read (GET request)
            HttpGet getRequest = new HttpGet("http://your-service-url/biginteger");
            HttpResponse getResponse = httpClient.execute(getRequest);

            if (getResponse.getStatusLine().getStatusCode() == 200) {
                String responseBody = EntityUtils.toString(getResponse.getEntity());
                BigInteger receivedValue = new BigInteger(responseBody);
                System.out.println("Received BigInteger value: " + receivedValue);
            } else {
                System.err.println("Error fetching BigInteger value. Status code: " + getResponse.getStatusLine().getStatusCode());
            }

            // Write (PUT request)
            HttpPut putRequest = new HttpPut("http://your-service-url/biginteger");
            String newValue = "123456789"; // Your desired BigInteger value
            putRequest.setEntity(new StringEntity(newValue));

            HttpResponse putResponse = httpClient.execute(putRequest);
            if (putResponse.getStatusLine().getStatusCode() == 204) {
                System.out.println("BigInteger value updated successfully.");
            } else {
                System.err.println("Error updating BigInteger value. Status code: " + putResponse.getStatusLine().getStatusCode());
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}


```
### Critique

### Example 15.4 prompt: I like the client but can you encapsulate the communication code into two methods. One will be called readInt and the other will be called writeInt?

### Code generated by copilot
```
import org.apache.http.HttpResponse;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.client.methods.HttpPut;
import org.apache.http.entity.StringEntity;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClients;
import org.apache.http.util.EntityUtils;

import java.math.BigInteger;

public class BigIntegerClient {

    private static final String SERVICE_URL = "http://your-service-url/biginteger";

    public static void main(String[] args) {
        BigIntegerClient client = new BigIntegerClient();
        BigInteger currentValue = client.readInt();
        System.out.println("Received BigInteger value: " + currentValue);

        // Update the value (example: 123456789)
        client.writeInt(new BigInteger("123456789"));
    }

    public BigInteger readInt() {
        try (CloseableHttpClient httpClient = HttpClients.createDefault()) {
            HttpGet getRequest = new HttpGet(SERVICE_URL);
            HttpResponse response = httpClient.execute(getRequest);

            if (response.getStatusLine().getStatusCode() == 200) {
                String responseBody = EntityUtils.toString(response.getEntity());
                return new BigInteger(responseBody);
            } else {
                System.err.println("Error fetching BigInteger value. Status code: " + response.getStatusLine().getStatusCode());
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return BigInteger.ZERO; // Default value if an error occurs
    }

    public void writeInt(BigInteger newValue) {
        try (CloseableHttpClient httpClient = HttpClients.createDefault()) {
            HttpPut putRequest = new HttpPut(SERVICE_URL);
            putRequest.setEntity(new StringEntity(newValue.toString()));

            HttpResponse response = httpClient.execute(putRequest);
            if (response.getStatusLine().getStatusCode() == 204) {
                System.out.println("BigInteger value updated successfully.");
            } else {
                System.err.println("Error updating BigInteger value. Status code: " + response.getStatusLine().getStatusCode());
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```
### Critique


## Exercises
1.


## References
[1] See Roy Fielding's PhD thesis: https://ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm
[2] OData: https://www.odata.org/
[3] Amazon Simple Storage Service: https://aws.amazon.com/s3/
