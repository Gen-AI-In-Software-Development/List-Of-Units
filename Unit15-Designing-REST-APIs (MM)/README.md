#  Unit15-Designing-REST-APIs

## Introduction

An API is an application programming interface. This means that an application developer (a programmer) can make calls to the functionality provided by the API. These calls often occur over a network, which transmits messages from one machine to another.
These messages describe the call or return values to and from the API.

There are many ways to design an API. Representational State Transfer (REST) is a particular style of API design that has become quite popular.

In this unit, we will explore a simple client and server application that uses the REST architectural style. We will ask Copilot to help us generate the server-side code using IntelliJ Ultimate’s implementation of the Java API for RESTful Web Services (JAX-RS).

Then, we will ask copilot to generate the client side code using Java and ask it to encapsulate the communication code in methods separate from the main class. This is an example of the proxy design pattern.

These examples use Microsoft copilot provided here: [Microsoft copilot](https://copilot.microsoft.com/).

## Use Case

The World Wide Web has been hugely successful. A browser is used to interact with a server via HTTP, URLs, and standard data representations such as HTML.

RESTful APIs are based on the same principles that were used in the construction of the web. For the origination and detailed explanation of these principles, see Roy Fielding’s PhD thesis[1]. This approach to API design has become widely popular. For two examples, see OData[2] and Amazon S3[3], which both utilize RESTful principles in their APIs.

## Prompts and Code Critique

We will show each prompt and the resulting code or response generated by Copilot. We will follow each example
with a short critique and rating. The ratings will be Poor, Fair, or Good.

### Example 15.1 prompt: Please explain any architectural advantages of developing a REST API.
Note: Copilot cited each comment with web URLs. It mentioned the following advantages:

### Notes on Copilot response
```

Interoperability because REST is based on standard protocols
Flexibility of integrating with different types of systems (web and mobile)
Language independence from any particular programming language
Easy maintenance allowing easy updates due to modular nature of REST API's
REST APIs are stateless and client side state need not be maintained on the server which simplifies requests and responses
REST APIs are popular

```
### Critique
While essentially correct, the answer did not mention that REST APIs are textual, providing human readability. In addition, copilot argues that since state is not maintained in the server, the request and response are simpler. But if by "request" and "response" it means the request and response messages, there is an error. The request and response messages may be more
complicated in a REST API than in an API where the server tracks application state.  Also, copilot did
not make clear what the distinction is between "interoperability" and "flexibility". Rating: Poor

### Example 15.2 prompt: I would like to use IntelliJ Ultimate and the built in Jakarta EE implementation of the Java API for RESTful web services (JAX-RS). Please provide a simple example that makes available a REST API. In particular, I would like to make available a single resource (a BigInteger) that can be read or written by a web service  client. The application should be called BigIntegerApplication and the actual resource should be called BigIntegerResource. I would like the URL to be /api/BigIntegerResource. The service should be written so that plain string data is passed on the network. I also would like directions on how to deploy this to IntelliJ ultimate using Tomcat. Thank you.

### Response from copilot
```
Step 1: Create the Project
Open IntelliJ Ultimate and create a new project.
Select Java Enterprise and choose Jakarta EE.
Choose Web Application as the project template.
Select Tomcat as the application server.
Click Next and configure the project name as BigIntegerApplication.

Step 2: Add Dependencies
Ensure your pom.xml (for Maven) includes the necessary dependencies for Jakarta EE and JAX-RS:

XML

<dependencies>
    <dependency>
        <groupId>jakarta.platform</groupId>
        <artifactId>jakarta.jakartaee-api</artifactId>
        <version>10.0.0</version>
        <scope>provided</scope>
    </dependency>
</dependencies>
AI-generated code. Review and use carefully. More info on FAQ.
Step 3: Create the Resource Class
Create a class named BigIntegerResource in the src/main/java directory:

Java

package com.example;

import jakarta.ws.rs.*;
import jakarta.ws.rs.core.MediaType;
import java.math.BigInteger;

@Path("/api/BigIntegerResource")
public class BigIntegerResource {

    private static BigInteger bigInteger = BigInteger.ZERO;

    @GET
    @Produces(MediaType.TEXT_PLAIN)
    public String getBigInteger() {
        return bigInteger.toString();
    }

    @POST
    @Consumes(MediaType.TEXT_PLAIN)
    public void setBigInteger(String value) {
        bigInteger = new BigInteger(value);
    }
}
AI-generated code. Review and use carefully. More info on FAQ.
Step 4: Create the Application Class
Create a class named BigIntegerApplication to configure the JAX-RS application:

package com.example;

import jakarta.ws.rs.ApplicationPath;
import jakarta.ws.rs.core.Application;

@ApplicationPath("/")
public class BigIntegerApplication extends Application {
}
AI-generated code. Review and use carefully. More info on FAQ.
Step 5: Configure web.xml (if needed)
If you’re using a web.xml file, ensure it includes the following configuration:

XML

<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee
         http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
         version="4.0">

    <servlet>
        <servlet-name>jakarta.ws.rs.core.Application</servlet-name>
        <servlet-class>org.glassfish.jersey.servlet.ServletContainer</servlet-class>
        <init-param>
            <param-name>jakarta.ws.rs.Application</param-name>
            <param-value>com.example.BigIntegerApplication</param-value>
        </init-param>
        <load-on-startup>1</load-on-startup>
    </servlet>

    <servlet-mapping>
        <servlet-name>jakarta.ws.rs.core.Application</servlet-name>
        <url-pattern>/api/*</url-pattern>
    </servlet-mapping>
</web-app>

AI-generated code. Review and use carefully. More info on FAQ.

Step 6: Deploy to Tomcat
Right-click on your project and select Add Framework Support.
Choose Tomcat and configure the server settings.
Build your project by selecting Build > Build Artifacts.
Deploy the artifact to Tomcat by selecting Run > Edit Configurations, then add a new Tomcat Server configuration.
Start the server and navigate to http://localhost:8080/api/BigIntegerResource to access your REST API.
That’s it! You now have a simple REST API that allows you to read and write a BigInteger resource. If you have any questions or need further assistance, feel free to ask!

```
### Critique
Overall, the directions are good. However, the URL created by IntelliJ was http://localhost:8080/BigIntegerApplication-1.0-SNAPSHOT/api/BigIntegerResource and not http://localhost:8080/api/BigIntegerResource. The name BigIntegerApplication-1.0-SNAPSHOT can be derived from the version and name tags in the pom.xml file. The pom.xml file is created automatically by IntelliJ. The string /api/BigIntegerResource is constructed by examining the Java source code. In this case, Copilot's suggestions cause confusion.

The Java code that was generated uses HTTP GET to retrieve the value of the BigInteger and an HTTP POST to make updates. For this API, a RESTful design would use the PUT verb rather than POST. PUT is idempotent and is used to update a resource and would be a natural fit for this scenario. Using POST rather than PUT will still work but represents a minor design flaw. Rating: Fair.

### Example 15.3 prompt: Continuing with our discussion, how can I visit the service with curl? That is, please provide two curl commands that can be used to test the service. One will call GET and the other will call POST. The URL that I am using to visit the service is http://localhost:8080/BigIntegerApplication-1.0-SNAPSHOT/api/BigIntegerResource.

### Curl commands generated by copilot:
```
curl -X GET http://localhost:8080/BigIntegerApplication-1.0-SNAPSHOT/api/BigIntegerResource

curl -X POST -d "123456789" -H "Content-Type: text/plain" http://localhost:8080/BigIntegerApplication-1.0-SNAPSHOT/api/BigIntegerResource

```
### Critique
These commands were tested and both work well. Note that Copilot took into account the correct URL to use. Rating: Good

### Example 15.4 prompt: Continuing with our discussion, I would like to test this service with a Java client that uses only standard Java. I do not want to use any client side libraries. I want the client to write the value 999 to the service and then read and display what was written.

### Response from copilot
```
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.net.HttpURLConnection;
import java.net.URL;

public class BigIntegerClient {

    private static final String BASE_URL = "http://localhost:8080/BigIntegerApplication-1.0-SNAPSHOT/api/BigIntegerResource";

    public static void main(String[] args) {
        try {
            // Write the value 999 to the service
            URL url = new URL(BASE_URL);
            HttpURLConnection postConnection = (HttpURLConnection) url.openConnection();
            postConnection.setRequestMethod("POST");
            postConnection.setRequestProperty("Content-Type", "text/plain");
            postConnection.setDoOutput(true);
            String value = "999";
            try (OutputStream os = postConnection.getOutputStream()) {
                os.write(value.getBytes());
                os.flush();
            }

            int responseCode = postConnection.getResponseCode();
            System.out.println("POST Response Code: " + responseCode);

            // Read the value from the service
            HttpURLConnection getConnection = (HttpURLConnection) url.openConnection();
            getConnection.setRequestMethod("GET");
            int getResponseCode = getConnection.getResponseCode();
            System.out.println("GET Response Code: " + getResponseCode);

            if (getResponseCode == HttpURLConnection.HTTP_OK) {
                try (BufferedReader in = new BufferedReader(new InputStreamReader(getConnection.getInputStream()))) {
                    String inputLine;
                    StringBuilder response = new StringBuilder();
                    while ((inputLine = in.readLine()) != null) {
                        response.append(inputLine);
                    }
                    System.out.println("GET Response: " + response.toString());
                }
            } else {
                System.out.println("GET request failed");
            }

        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```
### Critique
The HTTP response code of 204 is being used correctly because the POST request does not return any output. This client
side program works well but the communication code is mixed in with the application code. Rating: Fair.

In the next prompt, we will attempt to have Copilot isolate the communication code with a proxy design pattern.

### Example 15.5 prompt: Continuing with our discussion, I would like the client side code to have all communication related logic in separate methods. Currently the client mixes application logic with communication code. I would like to use a proxy design in my client side code. Please give me a new Java client. Thank you.


```
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.net.HttpURLConnection;
import java.net.URL;

public class BigIntegerProxy {

    private static final String BASE_URL = "http://localhost:8080/BigIntegerApplication-1.0-SNAPSHOT/api/BigIntegerResource";

    public int setBigInteger(String value) throws Exception {
        URL url = new URL(BASE_URL);
        HttpURLConnection postConnection = (HttpURLConnection) url.openConnection();
        postConnection.setRequestMethod("POST");
        postConnection.setRequestProperty("Content-Type", "text/plain");
        postConnection.setDoOutput(true);
        try (OutputStream os = postConnection.getOutputStream()) {
            os.write(value.getBytes());
            os.flush();
        }
        return postConnection.getResponseCode();
    }

    public String getBigInteger() throws Exception {
        URL url = new URL(BASE_URL);
        HttpURLConnection getConnection = (HttpURLConnection) url.openConnection();
        getConnection.setRequestMethod("GET");
        int responseCode = getConnection.getResponseCode();
        if (responseCode == HttpURLConnection.HTTP_OK) {
            try (BufferedReader in = new BufferedReader(new InputStreamReader(getConnection.getInputStream()))) {
                StringBuilder response = new StringBuilder();
                String inputLine;
                while ((inputLine = in.readLine()) != null) {
                    response.append(inputLine);
                }
                return response.toString();
            }
        } else {
            throw new RuntimeException("GET request failed with response code: " + responseCode);
        }
    }
}

public class BigIntegerClient {

    public static void main(String[] args) {
        BigIntegerProxy proxy = new BigIntegerProxy();
        try {
            // Write the value 999 to the service
            int postResponseCode = proxy.setBigInteger("999");
            System.out.println("POST Response Code: " + postResponseCode);

            // Read the value from the service
            String bigIntegerValue = proxy.getBigInteger();
            System.out.println("GET Response: " + bigIntegerValue);

        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```
### Critique
This code was tested against the BigIntegerService and ran fine without error. Separation of concerns was
done well with a proxy design. Client side libraries were not used. Instead, plain Java was used to connect to the service.
Rating: Good.


## Exercises
1. Use copilot to build a service that holds a pair of BigIntegers. This service should be RESTful and allow clients
to get or put a pair of integers. When put is called, a pair of integers will be transmitted to the service in the same call.
When get is called, a pair of integers will be sent to the client as the return value. All values placed on the network
will be simple string data, i.e., no JSON will be used.
2. Use copilot to modify exercise 1 so that the pair of integers is always transmitted in JSON format.
3. Use copilot to generate proxy code for exercise 2.
4. Use copilot to build a simple service that makes good use of the four primary HTTP verbs: GET, POST, PUT, and DELETE.
5. Use copilot to generate four curl commands that visit the service created in exercise 4.
6. Use copilot to build the same service as described in this unit but use Javascript rather than Java.
7. Test the Javascript service in exercise 6 using node.js.

## References
[1] See Roy Fielding's PhD thesis: https://ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm

[2] OData: https://www.odata.org/

[3] Amazon Simple Storage Service: https://aws.amazon.com/s3/
