# Unit02 Problem Solving And Pseudocode
## Introduction

In this unit, we will ask copilot to generate pseudocode for various problems.
These examples use Microsoft copilot provided here: [Microsoft copilot](https://copilot.microsoft.com/).

## Use Case

Pseudocode is utilized by both experienced developers and novices. The idea
is to postpone the writing of actual programming code and work at a higher level. This higher
level coding abstracts away programming language details. When working with pseudocode, the
developer need not worry about programming language syntax.

Pseudocode is closer to natural language and can be converted to programming code in
the programming language of choice.

Pseudocode plays a crucial role in problem-solving and problem decomposition.

## Prompts and Code Critique

We will show each prompt and the resulting pseudocode generated by Copilot. We will follow each example
with a short critique and rating. The ratings will be Poor, Fair, or Good.

### Example 2.1 prompt: We would like to transmit up to eight different messages over a noisy communication channel using three bits per messages (000..111). We suppose that the channel may introduce a single bit error in any message, we want to add a parity bit (even parity) to each message. In this way, a receiver will be able to detect a single bit error and, perhaps, request a retransmission. The messages that we are sending are denoted as 0,1,2..,7 in base 10. We need a pseudocode description that reads an integer in base 10 (between 0 and 7) and displays the bits to be transmitted. The parity bit will be the leftmost bit and the base 10 integer will be represented in base 10. For example, if the pseudocode reads the base 10 integer 4, the output will be 1100. [1]


### Generated Pseudocode:
```
FUNCTION encode_message_with_parity(integer message)
    // Convert the message to a 3-bit binary string
    binary_message = CONVERT_TO_BINARY(message, 3 bits)

    // Calculate the number of '1's in the binary message
    count_ones = COUNT('1', binary_message)

    // Determine the parity bit (even parity)
    IF count_ones IS EVEN THEN
        parity_bit = '0'
    ELSE
        parity_bit = '1'
    END IF

    // Combine the parity bit with the binary message
    encoded_message = CONCATENATE(parity_bit, binary_message)

    RETURN encoded_message
END FUNCTION

// Example usage:
// Read an integer between 0 and 7 from the user
integer input = READ_INTEGER("Enter a base 10 integer (between 0 and 7): ")

// Validate the input
IF input IS BETWEEN 0 AND 7 THEN
    // Encode the message and display the result
    DISPLAY("Encoded message for ", input, ": ", encode_message_with_parity(input))
ELSE
    DISPLAY("Invalid input. Please enter a number between 0 and 7.")
END IF


```

### Critique
If the user enters the integer 3, the if statement after the read will be true and the algorithm will
call DISPLAY. A three bit binary string will be created with the value 011. The value of count_ones will be set
to 2 (which is even) and therefore the encoded value of 0011 will be returned.

This is a clear pseudocode description of an algorithm that performs as expected. Rating: Good.

### Example 2.2 prompt: As a follow up, please show the code on the receiver side.

### Generated pseudocode:

```
FUNCTION decode_message_with_parity(encoded_message)
    // Split the parity bit from the rest of the message
    parity_bit = encoded_message[0]
    binary_message = encoded_message[1 to end]

    // Calculate the number of '1's in the binary message
    count_ones = COUNT('1', binary_message)

    // Check if the parity bit matches the message
    IF (parity_bit == '0' AND count_ones IS EVEN) OR (parity_bit == '1' AND count_ones IS ODD) THEN
        // Parity is correct, no error detected
        RETURN "No error detected. Message is: " + binary_message
    ELSE
        // Parity is incorrect, error detected
        RETURN "Error detected in the message."
    END IF
END FUNCTION

// Example usage:
// Read the encoded message from the user
encoded_input = READ_STRING("Enter the received encoded message: ")

// Validate the input length (should be 4 bits)
IF LENGTH(encoded_input) == 4 THEN
    // Decode the message and display the result
    DISPLAY(decode_message_with_parity(encoded_input))
ELSE
    DISPLAY("Invalid input. Please enter a 4-bit encoded message.")
END IF

```
### Critique
This code also appears to be well written and correct. The receiver reads a string, checks its length, and calls
the decode_message_with_parity. The parity bit is extracted and checked to see if it matches the parity of the message.
Low level details have been left to the developer and this is expected in pseudocode.
Rating: Good.

## Exercises
1. A single parity bit is useful for detecting if exactly 1 bit was flipped during transmission. However, it does not tell the receiver which bit caused the error. Using Copilot, generate pseudocode on the sender side that will use a Hamming code to add some check bits to the three bit messages. These bits will allow the receiver to detect if a single error occurred and to know which bit got flipped.
2. Following exercise 1, ask copilot to create a receiver for the message encoded with the Hamming code.
3. Using a pencil and paper, desk check the sender and receiver code that was generated in Exercises 1 and 2. How do you rate the pseudocode? Poor, Fair, or Good?
4. With respect to questions 1-3, is desk checking enough or do you feel that you need a deeper understanding of Hamming codes?



## References
[1] This example is motivated by the discussion in "Foundations of Computer Science", Aho, Ullman, pages 35-37.
