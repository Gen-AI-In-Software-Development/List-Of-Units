#  Unit07-Pytest-For-Python

## Introduction

In this unit, we'll investigate the standard unit testing framework for Python, pytest. The goal is to review test cases generated by Microsoft Copilot and provide feedback on the generated test cases.

## Use Case
Unit test cases for Java with junit are discussed in Unit06. Test cases for Python using pytest have the same basic idea. A generic test case has the form <input data, expected results, actual results> along with an indication whether the test case passed or failed. pytest provides a structured setting for creating and running test cases for Python functions. When the test cases are executed, a summary of the results is given: a green icon indicates a passed test case and a red icon indicates a failure.

In pytest, test cases are created by defining functions using the naming convention "test_<mytest>". The body of the function will contain one or more assert( ) statements that call a function to be tested (with the test input data as parameters), comparing its results against the expected results. For example:

```
def test_myFunction():
   assert myFunction(3, 4) == 5
```

Here, the function test_myFunction() is used to test the actual function "myFunction", the input data are the parameters 3 and 4, and the expected results is 5. Running pytest in VSCode can be done by simply running the test function's module, but the preferred way is to use the test runner (symbolized by the flask icon).

## Prompts and Code Critique

### Example 7.1 Calculator

Here are several methods that implement a simple calculator function, including addition, subtraction, multiplication, and division. These functions are similar to the calculator example from Unit03.

```
def add(a, b):
    return a + b

def subtract(a, b):
    return a - b

def multiply(a, b):
    return a * b

def divide(a, b):
    if b == 0:
        raise ValueError("Can't divide by zero!")
    return a / b
```

### Prompt: Generate test methods for all the functions in pytest

### Generated Code

```
import pytest
from calculator import add, subtract, multiply, divide

def test_add():
    assert add(1, 2) == 3
    assert add(-1, -2) == -3
    assert add(-1, 1) == 0

def test_subtract():
    assert subtract(1, 2) == -1
    assert subtract(-1, -2) == 1
    assert subtract(-1, 1) == -2

def test_multiply():
    assert multiply(2, 3) == 6
    assert multiply(-1, -2) == 2
    assert multiply(-1, 2) == -2

def test_divide():
    assert divide(4, 2) == 2
    assert divide(-4, -2) == 2
    assert divide(-4, 2) == -2
    with pytest.raises(ValueError):
        divide(1, 0)
```

### Critique

The test cases provide several sets of test data. The tests pass, but the test data is relatively simple. Rating: Fair

### Prompt: Generate more test cases with complex float number

### Generated Code

```
def test_add_with_complex_float():
    assert add(1.5, 2.5) == 4.0
    assert add(-1.5, -2.5) == -4.0
    assert add(1.5, -2.5) == -1.0
    assert add(complex(1, 2), complex(2, 3)) == complex(3, 5)

def test_subtract_with_complex_float():
    assert subtract(1.5, 2.5) == -1.0
    assert subtract(-1.5, -2.5) == 1.0
    assert subtract(1.5, -2.5) == 4.0
    assert subtract(complex(5, 5), complex(2, 3)) == complex(3, 2)

def test_multiply_with_complex_float():
    assert multiply(2.5, 4.0) == 10.0
    assert multiply(-1.5, -2.5) == 3.75
    assert multiply(-1.5, 2.5) == -3.75
    assert multiply(complex(1, 2), complex(2, 3)) == complex(-4, 7)

def test_divide_with_complex_float():
    assert divide(5.0, 2.0) == 2.5
    assert divide(-4.5, -1.5) == 3.0
    assert divide(-4.5, 1.5) == -3.0
    assert divide(complex(2, 4), complex(1, 2)) == complex(2.0, 0.0)
    with pytest.raises(ValueError):
        divide(1.0, 0.0)
```

### Critique

The test cases provide more examples and include tests with floating-point numbers, making them more complex compared to the previous examples. Also, the test passes. Rating: Fair

This is an example of a Copilot failure.

### Prompt: Generate at least 3 different test cases for each method with 3 random floating-point numbers with at least 3 decimal places of precision

### Generated Code

```
def test_add_with_random_floats():
    assert add(1.123, 2.456) == 3.579
    assert add(-1.789, -2.321) == -4.110
    assert add(3.456, -2.123) == 1.333

def test_subtract_with_random_floats():
    assert subtract(5.678, 2.123) == 3.555
    assert subtract(-1.234, -2.345) == 1.111
    assert subtract(4.567, -3.210) == 7.777

def test_multiply_with_random_floats():
    assert multiply(2.123, 3.456) == 7.339008
    assert multiply(-1.111, -2.222) == 2.469642
    assert multiply(-2.345, 3.456) == -8.10672

def test_divide_with_random_floats():
    assert divide(6.789, 2.123) == 3.198297693920336
    assert divide(-7.890, -2.345) == 3.3650316455696204
    assert divide(9.876, 3.210) == 3.0760122699386504
    with pytest.raises(ValueError):
        divide(1.234, 0.000)
```

### Critique

Copilot provided examples that include relatively complex floating-point numbers but cannot produce correct results, especially when dealing with the multiplication and division of random floating-point numbers. Rating: Poor

### Example 7.2 Point

The following Point class is a basic point class, similar to the one we used in Unit 3

```
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def distance(self, other):
        return ((self.x - other.x) ** 2 + (self.y - other.y) ** 2) ** 0.5
```



### Prompt: Generate the test method for distance method in pytest.

### Generated Code

```
import pytest
from point import Point

def test_distance():
    point1 = Point(0, 0)
    point2 = Point(3, 4)
    expected_distance = 5.0
    assert point1.distance(point2) == expected_distance, "The distance calculation is incorrect"
```



### Critique

This prompt provides a very simple test case for the distance method. There are too few test cases and the test data is overly simplistic. Rating: Poor

### Prompt: Generate more test cases.

### Generated Code

```
def test_distance_same_point():
    point = Point(0, 0)
    expected_distance = 0.0
    assert point.distance(point) == expected_distance, "Distance to itself should be 0"

def test_distance_positive_coordinates():
    point1 = Point(1, 2)
    point2 = Point(4, 6)
    expected_distance = 5.0
    assert point1.distance(point2) == expected_distance, "Distance calculation with positive coordinates is incorrect"

def test_distance_negative_coordinates():
    point1 = Point(-1, -2)
    point2 = Point(-4, -6)
    expected_distance = 5.0
    assert point1.distance(point2) == expected_distance, "Distance calculation with negative coordinates is incorrect"

def test_distance_mixed_coordinates():
    point1 = Point(-1, 2)
    point2 = Point(3, -4)
    expected_distance = ((-1 - 3) ** 2 + (2 + 4) ** 2) ** 0.5
    assert point1.distance(point2) == expected_distance, "Distance calculation with mixed coordinates is incorrect"
```

### Critique

This prompt generates more comprehensive test cases, covering several different scenarios, and the tests pass. However, the data is still relatively simple. Rating: Fair

### Prompt: Generate at least 3 test cases with some random numbers

### Generated Code

```
def test_distance_random_case_1():
    point1 = Point(7, 14)
    point2 = Point(1, 8)
    expected_distance = ((7 - 1) ** 2 + (14 - 8) ** 2) ** 0.5
    assert point1.distance(point2) == expected_distance, "Random test case 1 failed"

def test_distance_random_case_2():
    point1 = Point(-5, -3)
    point2 = Point(-2, -6)
    expected_distance = ((-5 + 2) ** 2 + (-3 + 6) ** 2) ** 0.5
    assert point1.distance(point2) == expected_distance, "Random test case 2 failed"

def test_distance_random_case_3():
    point1 = Point(20, 30)
    point2 = Point(50, 80)
    expected_distance = ((20 - 50) ** 2 + (30 - 80) ** 2) ** 0.5
    assert point1.distance(point2) == expected_distance, "Random test case 3 failed"
```

### Critique

This prompt used some random numbers generated by Copilot itself and ensured test validity by providing the calculation code to avoid Copilot's calculation of results. The test passes. Rating: Good

## Exercise

1. In Example 6.1, ask Copilot to fix the precision problems in the code.
2. In Example 6.2, try to generate test cases with floating-point numbers that have more digits.
3. Try to write a method that converts Celsius degrees to Fahrenheit degrees and ask Copilot to generate some test cases.

## References
[1] Unit testing, https://en.wikipedia.org/wiki/Unit_testing

[2] pytest, https://docs.pytest.org/en/stable/
